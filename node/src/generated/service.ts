// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.20.3
// source: service.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientReadableStream,
  type ClientWritableStream,
  type handleBidiStreamingCall,
  type handleClientStreamingCall,
  type handleServerStreamingCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { DataChunk, Id } from "./common";
import { Empty } from "./google/protobuf/empty";
import { LogMessage } from "./log";
import { OrchestratorMessage } from "./orchestrator";
import { RunnerMessage } from "./runner";

export const protobufPackage = "rdfc";

export type RunnerService = typeof RunnerService;
export const RunnerService = {
  connect: {
    path: "/rdfc.Runner/connect",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: OrchestratorMessage) => Buffer.from(OrchestratorMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OrchestratorMessage.decode(value),
    responseSerialize: (value: RunnerMessage) => Buffer.from(RunnerMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RunnerMessage.decode(value),
  },
  sendStreamMessage: {
    path: "/rdfc.Runner/sendStreamMessage",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: DataChunk) => Buffer.from(DataChunk.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DataChunk.decode(value),
    responseSerialize: (value: Id) => Buffer.from(Id.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Id.decode(value),
  },
  receiveStreamMessage: {
    path: "/rdfc.Runner/receiveStreamMessage",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Id) => Buffer.from(Id.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Id.decode(value),
    responseSerialize: (value: DataChunk) => Buffer.from(DataChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DataChunk.decode(value),
  },
  logStream: {
    path: "/rdfc.Runner/logStream",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: LogMessage) => Buffer.from(LogMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogMessage.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
} as const;

export interface RunnerServer extends UntypedServiceImplementation {
  connect: handleBidiStreamingCall<OrchestratorMessage, RunnerMessage>;
  sendStreamMessage: handleBidiStreamingCall<DataChunk, Id>;
  receiveStreamMessage: handleServerStreamingCall<Id, DataChunk>;
  logStream: handleClientStreamingCall<LogMessage, Empty>;
}

export interface RunnerClient extends Client {
  connect(): ClientDuplexStream<OrchestratorMessage, RunnerMessage>;
  connect(options: Partial<CallOptions>): ClientDuplexStream<OrchestratorMessage, RunnerMessage>;
  connect(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<OrchestratorMessage, RunnerMessage>;
  sendStreamMessage(): ClientDuplexStream<DataChunk, Id>;
  sendStreamMessage(options: Partial<CallOptions>): ClientDuplexStream<DataChunk, Id>;
  sendStreamMessage(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<DataChunk, Id>;
  receiveStreamMessage(request: Id, options?: Partial<CallOptions>): ClientReadableStream<DataChunk>;
  receiveStreamMessage(
    request: Id,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<DataChunk>;
  logStream(callback: (error: ServiceError | null, response: Empty) => void): ClientWritableStream<LogMessage>;
  logStream(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<LogMessage>;
  logStream(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<LogMessage>;
  logStream(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<LogMessage>;
}

export const RunnerClient = makeGenericClientConstructor(RunnerService, "rdfc.Runner") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RunnerClient;
  service: typeof RunnerService;
  serviceName: string;
};
